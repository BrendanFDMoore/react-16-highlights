import { Appear, Head } from 'mdx-deck';
import { Split } from 'mdx-deck/layouts';
import { CodeSurfer } from 'mdx-deck-code-surfer';

<Head>
  <title>React 16 Highlights</title>
  {/* <meta name='twitter:card' content='summary_large_image' />
  <meta name='twitter:site' content='@jxnblk' />
  <meta name='twitter:title' content='My Presentation' />
  <meta name='twitter:description' content='A really great presentation' />
  <meta name='twitter:image' content='https://example.com/card.png' /> */}
</Head>


# React 16
<Appear>
  <img src={'https://i.pinimg.com/originals/21/6c/4e/216c4eb9707772c378fe76ba4929bf46.gif'} />
  <p></p>
</Appear>

---
# Highlights

<Appear>
  <h3>Not everything</h3>
  <h4>Lots of resources online to learn more -- start with the React changelog and blog</h4>
</Appear>

---
## v16.0

* Fiber
* Fragments (& strings) 
* Portals
* Error Boundary

---

# What is Fiber?

<Appear>
  <h2>A new rendering engine -- that's all.</h2>
  <p>But there are some consequences.</p>
  <p>Deprecation <i>warning</i>: componentWillReceiveOfProps, componentWillMount, componentWillUpdate</p>
  <p>Expose new lifecycle methods: getDerivedStateFromProps (and getSnapshotBeforeUpdate)</p>
  <p><strong>Prep for async changes inter-instance lifecycle</strong></p>
</Appear>

```notes
Fiber isn't a "feature" you would be using directly, it's plumbing.
It was a necessary step to _enable_ other features like lazy/Suspense and concurrent rendering.
```
---
## Why is this a problem?

<Appear>
  <p>Imagine we re-render some component with lifecycle...</p>
  <p>Let's call the first instance A and the second B</p>
  <p style={{ display: 'block', backgroundColor:'#cccccc', width: '80%', padding: '10p'}}>
    When replacing &lt;A /&gt; with &lt;B /&gt;, B.componentWillMount now always happens before A.componentWillUnmount. Previously, A.componentWillUnmount could fire first in some cases.
    <br />-- React changelog
  </p>
</Appear>

---

export default Split

<Appear>
  <h4>Before</h4>
  <ul>
    <li style={{listStyleType:'none'}}>Trigger First Render</li>
    <li style={{listStyleType:'none'}}>Mount A</li>
    <li style={{listStyleType:'none'}}>Trigger Second Render</li>
    <li style={{listStyleType:'none'}}>Unmount A</li>
    <li style={{listStyleType:'none', color: 'red'}}>Mount B</li>
  </ul>
</Appear>

<Appear>
  <h4>After</h4>
  <ul>
    <li style={{listStyleType:'none'}}>Trigger First Render</li>
    <li style={{listStyleType:'none'}} >Mount A</li>
    <li style={{listStyleType:'none'}}>Trigger Second Render</li>
    <li style={{listStyleType:'none', color: 'red'}}>Mount B</li>
    <li style={{listStyleType:'none'}}>Unmount A</li>
  </ul>
</Appear>

---

## So what?

<Appear>
  <p>I say we take a look at Table Orchestrator</p>
  <p></p>
</Appear>

---

<CodeSurfer
  code={require("!raw-loader!./code/to-extract.js")}
  language="javascript"
  steps={[
    { lines: [1], notes: "In the constructor..." },
    { range: [4, 8], notes: "...we dispatch an init action."},
    { range: [11, 16], notes: "And then in componentWillUnmount, we (usually) delete the state" },
    { notes: "Who wants to describe the problem is?" },
  ]}
/>

---

## The fix
<Appear>
  <p>Well, workaround.</p>
  <p></p>
</Appear>

---

<CodeSurfer
  code={require("!raw-loader!./code/to-extract-fix.js")}
  language="javascript"
  steps={[
    { lines: [5, 7], notes: "Assign a UUID to the instance..." },
    { lines: [22, 26], notes: "...and track the latest initialized instance." },
    { lines: [17], notes: "Then, when we unmount, the delete carries the instance too" },
    { range: [31, 33], notes: "and we check the id before clearing the state." },
  ]}
/>
---
# Takeaway 
<Appear>
  <img src={'https://thumbs.gfycat.com/MagnificentFoolishArcticfox-size_restricted.gif'} />
  <p>Changes to lifecycle and less control inter-instance</p>
</Appear>
---

# Fragments & Strings
<Appear>
  <p>Get rid of messy wrapping elements in the DOM</p>
  <p></p>
</Appear>
---
# Fragments
---
export default Split

```jsx
const FancyList = () => (
  <FancyWrapper>
    <SomeChildList />
  </FancyWrapper>
);

const SomeChildList = () => (
  <div> ðŸ‘ˆðŸ‘ˆðŸ‘ˆ
    <Child key="A" />
    <Child key="B" />
    <Child key="C" />
  </div> ðŸ‘ˆðŸ‘ˆðŸ‘ˆ
);
```

```jsx
const FancyList = () => (
  <FancyWrapper>
    <SomeChildList />
  </FancyWrapper>
);

const SomeChildList = () => (
  <React.Fragment> ðŸ‘ˆðŸ‘ˆðŸ‘ˆ
    <Child key="A" />
    <Child key="B" />
    <Child key="C" />
  </React.Fragment> ðŸ‘ˆðŸ‘ˆðŸ‘ˆ
);
```

---

 Shorthand: `<> ... </>`
<Appear>
  <p>...but we need to upgrade Babel first.</p>
  <p></p>
</Appear>
 
---
# Strings
---
export default Split

```jsx
const HelloThere = ({name}) => (
  <span> ðŸ‘ˆðŸ‘ˆðŸ‘ˆ
    {`Hello, ${name}!`}
  </span> ðŸ‘ˆðŸ‘ˆðŸ‘ˆ
);
```

```jsx
const HelloThere = ({name}) => (
  `Hello, ${name}!` ðŸ‘‹
);
```
---

# Portals
<Appear>
  <p>Render somewhere else.</p>
  <img src={'https://media.giphy.com/media/11eF6JYhWnSRa0/giphy-downsized-large.gif'} />
</Appear>

---

```jsx
render() {
  // ...
  return (
    <div>
      {this.props.children}
    </div>
  );
}
```
---

```jsx
render() {
  // ...
  return ReactDOM.createPortal(
    this.props.children,
    domNode
  );
}
```
---
```jsx

const Notifications = ({ messages }) =>
  ReactDOM.createPortal(
    messages.map(m => <Notification text={m}/>),
    document.getElementById('notify-area');
  );
}
...
// in some form component
render() {
  <React.Fragment>
    <UserInputVisualization />
    <Notifications message={this.errorMessages} />
  </React.Fragment>
}
```
---

# Error Boundary
<Appear>
  <p>Allows components to catch errors</p>
  <p>Expose new lifecycle methods: `componentDidCatch` and `getDerivedStateFromError`</p>
</Appear>

```notes
getDerivedStateFromError parallels getDerivedStateFromProps -- return a state update object.
```

---

<CodeSurfer
  code={require("!raw-loader!./code/error-boundary.js")}
  language="javascript"
  steps={[
    { lines: [4], notes: "We start without an error" },
    { range: [7, 10], notes: "if we need to update our component state." },
    { range: [12, 15], notes: "we can also manage other externalities here." },
    { range: [17, 21], notes: "We consume the error indication value now in the render." },
    { notes: "And ensure the wrapped components are behaving..." },
  ]}
/>
---
  <img src={'https://media.giphy.com/media/3o7bu1iM5MSwG2y7NS/giphy.gif'} />
---

## v16.1 & 16.2

<Appear>
  <h3><i>Mostly fixes and optimizations</i></h3>
  <img src={'https://y.yarn.co/e773e6ae-790a-4c10-918b-1d941cb9dee0_text_hi.gif'} />
</Appear>
---

## v16.3 
  * Context
  * Strict Mode
  * Packages: Lifecycle Compat, Subscriptions, ReactIs

---

# Context

Allows passing data between distant component tree nodes without prop drilling.
You're already using it! The `redux` wrapper `Provider` does exactly this.

```jsx
const { store } = await configureStore(window.REDUX_STATE);
// ...
const App = () => (
  <Wrapper className={theme.main} id="main-section">
    <Provider store={store}> ðŸ‘ˆðŸ‘ˆðŸ‘ˆ
      <InitializerContainer>
        <Layout />
      </InitializerContainer>
    </Provider>
  </Wrapper>
);
```
---

TODO: Add CodeSurfer look at ContextDemo first??
---
import ContextDemo from './components/ContextDemo'

<ContextDemo />

---

# Strict Mode

Tool for validating compatibility with new API
No visual elements, just extra checks

```jsx
import React from 'react';

function ExampleApplication() {
  return (
    <div>
      <Header />
      <React.StrictMode> ðŸ‘ˆðŸ‘ˆðŸ‘ˆ
        <div>
          <ComponentOne />
          <ComponentTwo />
        </div>
      </React.StrictMode>
      <Footer />
    </div>
  );
}
```
---

# Lifecycle Compat
<Appear>
  <p>Enable code running older React to target new lifecycle methods (eg, 15)</p>
  <p>Primarily targetted at library developers, avoid major version bumps</p>
</Appear>

---

# ReactIs (TODO: maybe remove this?)
<Appear>
  <p>First-party tooling for comparing element types</p>
  <p></p>
</Appear>

---

```jsx
import React from "react";
import * as ReactIs from 'react-is';

ReactIs.isElement(<div />); // true
ReactIs.typeOf(<div />) === ReactIs.Element; // true

ReactIs.isFragment(<></>); // true
ReactIs.typeOf(<></>) === ReactIs.Fragment; // true

```
---

# v16.4 & 16.5: 
  * Profiler

---
# Profiler
<Appear>
  <p>Support for visualizing concurrent rendering</p>
  <p>Now built into React DevTools</p>
  <img src={'https://reactjs.org/filtering-commits-683b9d860ef722e1505e5e629df7ef7e.gif'} />
</Appear>
---
# v16.6
  * lazy & Suspense
  * memo  

---

# lazy & Suspense
<Appear>
  <p>Lazy allows for easily defering load & code splitting</p>
  <p>Suspense allows showing a placeholder component while we wait for something to load</p>
  <img src={'https://media.giphy.com/media/l0ExgJHsbXtzitqVO/giphy.gif'} />
  <p>Essentially this is the same thing we're doing with FetchComponent</p>
</Appear>

---
import LazyDemo from './components/LazyDemo'

<LazyDemo />

---
# Memo

<Appear>
  <p>Enables Stateless Functional Cmponents to be memoized on props</p>
  <p>Works like PureComponent, but for SFCs</p>
</Appear>

---

import MemoDemo from './components/MemoDemo'

<MemoDemo />

---
# We Can See The Future!

* 16.7 (alpha)
  * Concurrent (nÃ©e _async_) rendering
  * Hooks
* ...and beyond
  * Scheduler
  * Cache

---
# Questions?
<Appear>
  <p>Bueller?</p>
  <img src={'https://media.giphy.com/media/yODVOeMxWBwBO/giphy.gif'} />
</Appear>